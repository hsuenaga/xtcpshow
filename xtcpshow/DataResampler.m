// Copyright (c) 2013
// SUENAGA Hiroki <hiroki_suenaga@mac.com>. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//
//  DataResampler.m
//  xtcpshow
//
//  Created by SUENAGA Hiroki on 2013/08/02.
//  Copyright (c) 2013 SUENAGA Hiroki. All rights reserved.
//
#include "math.h"

#import "DataResampler.h"
#import "TrafficIndex.h"
#import "TrafficData.h"
#import "DerivedData.h"
#import "ComputeQueue.h"
#import "FIR.h"

// Gaussian filter.
// larger value is more better and more slow.
@implementation DataResampler

- (id)init
{
    self = [super init];

    return self;
}

- (void)invalidValueException
{
	NSException *ex;

	ex = [NSException exceptionWithName:@"Invalid value"
				     reason:@"Invalid value in DataResampler"
				   userInfo:nil];
	@throw ex;
}

- (void)updateParams
{
    // convert units
    tick = _outputTimeLength / _outputSamples; // [sec/sample]
    bytes2mbps = 8.0 / tick; // [bps]
    bytes2mbps = bytes2mbps / 1000.0 / 1000.0; // [Mbps]
    dataLength = -(_outputTimeLength + _MATimeLength);
    
    // allocate FIR
    _FIR = [FIR FIRwithTap:ceil(_MATimeLength/tick)];
    
    NSUInteger maxSamples = _outputSamples + [_FIR tap];
    _output = [ComputeQueue queueWithZero:maxSamples];
    _output.last_used = nil;

#if 0
    [self dumpParams];
#endif
    running = TRUE;
}

- (void)dumpParams
{
    NSLog(@"===== Resampler =====");
    NSLog(@"Duration: %f [sec]", _outputTimeLength);
    NSLog(@"Plot: %lu [point]", (unsigned long)_outputSamples);
    NSLog(@"Tick: %f [sec/point]", tick);
    NSLog(@"FIR Duration: %f [sec]", _MATimeLength);
    NSLog(@"FIR Taps: %lu [point]", [_FIR tap]);
    NSLog(@"Output samples: %lu [point]", _outputSamples + [_FIR tap]);
}

- (void)purgeData
{
    running = FALSE;
}

- (NSDate *)roundDate:(NSDate *)date toTick:(NSTimeInterval)tick
{
	NSTimeInterval unixTime;

	unixTime = [date timeIntervalSince1970];
	unixTime = floor(unixTime / tick) * tick;
	return [NSDate dateWithTimeIntervalSince1970:unixTime];
}

- (void)resampleData:(Queue *)input
{
	NSDate *start, *end;
    
    if (!running)
        [self updateParams];

	// get range of time
	end = [input.last_used dateByAddingTimeInterval:_outputTimeOffset];
	start = [self roundDate:[end dateByAddingTimeInterval:dataLength] toTick:tick];

	if (!_output.last_used) {
		// 1st time. adjust input date.
		[input seekToDate:start];
		_output.last_used = start;
	}
	else {
		// continue from last update
		start = [start laterDate:_output.lastDate];
		start = [start dateByAddingTimeInterval:tick];
	}
	
	// filter
	for (NSDate *slot = start;
         [slot laterDate:end] == end;
         slot = [slot dateByAddingTimeInterval:tick]) {
		DerivedData *sample;
		NSUInteger sample_count = 0;
        uint64_t slot_sum = 0;
		// Step1: folding(sum) source data before slot
		while ([input nextDate] &&
		       [slot laterDate:[input nextDate]] == slot) {
			TrafficData *source = [input readNextData];
            slot_sum += [source bytes];
			sample_count += source.numberOfSamples;
			_output.last_used = source.timestamp;
		}
		sample = [DerivedData dataWithSingleFloat:(float)slot_sum];

		// Step2: FIR
        sample = [self.FIR filter:sample];

		// Step3: convert unit of sample
		sample = [DerivedData dataWithFloat:([sample floatValue] * bytes2mbps) atDate:slot fromSamples:sample_count];

		// finalize and output sample
		[_output enqueue:sample withTimestamp:[sample timestamp]];
	}

	// get additional data(noise) generated by filter
	_overSample = [_output count] - _outputSamples;
	_lastInput = input;
}

- (void)resampleDataWithIndex:(TrafficIndex *)index atDate:(NSDate *)date;
{
    NSDate *start, *end;
    
    if (!running)
        [self updateParams];
    
    // get range of time
    end = [self roundDate:[date dateByAddingTimeInterval:_outputTimeOffset] toTick:tick];
    start = [self roundDate:[end dateByAddingTimeInterval:dataLength] toTick:tick];
    
    // PID block
    NSUInteger plots = 0;
    for (NSDate *slot = start;
         [slot laterDate:end] == end;
         slot = [slot dateByAddingTimeInterval:tick]) {
        NSDate *prev = [slot dateByAddingTimeInterval:(-tick)];
        NSDate *next = [slot dateByAddingTimeInterval:(tick)];

        // Step1: get differential value
        NSUInteger pbits = [index bitsAtDate:prev];
        NSUInteger nbits = [index bitsAtDate:next];
        if (pbits > nbits) {
#ifdef DEBUG
            [index openDebugFile:@"inconsistent_tree.dot"];
            [index dumpTree:TRUE];
#endif
            NSException *ex = [NSException exceptionWithName:@"Inconsistent Data" reason:@"Data is decreadsed." userInfo:NULL];
            @throw ex;
        }
        NSUInteger bits = nbits - pbits;
        NSUInteger pkts = [index samplesAtDate:slot] - [index samplesAtDate:prev];
        double mbps = (double)bits / ((tick * 2.0) * (1000.0 * 1000.0));
        DerivedData *sample = [DerivedData dataWithFloat:mbps atDate:slot fromSamples:pkts];
        
        // Step2: FIR
        sample = [self.FIR filter:sample];
        
        // finalize and output sample
        [_output enqueue:sample withTimestamp:slot];
        plots++;
    }
    
    // get additional data(noise) generated by filter
    _overSample = [_output count] - _outputSamples;
 }
@end
