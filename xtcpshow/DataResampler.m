// Copyright (c) 2013
// SUENAGA Hiroki <hiroki_suenaga@mac.com>. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//
//  DataResampler.m
//  xtcpshow
//
//  Created by SUENAGA Hiroki on 2013/08/02.
//  Copyright (c) 2013 SUENAGA Hiroki. All rights reserved.
//
#import "math.h"

#import "DataResampler.h"
#import "TrafficIndex.h"
#import "TrafficData.h"
#import "TrafficDB.h"
#import "DerivedData.h"
#import "ComputeQueue.h"
#import "FIR.h"

@interface DataResampler ()
- (NSDate *)roundDate:(NSDate *)date toTick:(NSTimeInterval)tick;
- (void)dumpParams;
- (void)invalidValueException;
@end

@implementation DataResampler {
    FIR *filterFIR;
    BOOL write_protect;
    BOOL running;
    double tick;
    NSTimeInterval dataLength;
}
@synthesize output;
@synthesize outputSamples;
@synthesize outputTimeLength;
@synthesize outputTimeOffset;
@synthesize FIRTimeLength;
@synthesize overSample;

- (DataResampler *)init
{
    self = [super init];
    self->_outputLock = [NSRecursiveLock new];
    return self;
}

- (void)updateParams
{
    // convert units
    tick = outputTimeLength / outputSamples; // [sec/sample]
    dataLength = outputTimeLength + FIRTimeLength;
    
    // allocate FIR
    filterFIR = [FIR FIRwithTap:ceil(FIRTimeLength/tick)];
    
    NSUInteger maxSamples = outputSamples + [filterFIR tap];
    output = [ComputeQueue queueWithZero:maxSamples];

#ifdef DEBUG
    [self dumpParams];
#endif
    running = TRUE;
}

- (void)purgeData
{
    running = FALSE;
    output.last_used = nil;
}

- (void)resampleDataBase:(TrafficDB *)dataBase atDate:(NSDate *)date;
{
    NSDate *start, *end;
    
    [self.outputLock lock];
    
    if (!running)
        [self updateParams];
    
    // get range of time
    end = [self roundDate:[date dateByAddingTimeInterval:outputTimeOffset] toTick:tick];
    start = [self roundDate:[end dateByAddingTimeInterval:(-dataLength)] toTick:tick];
    if (output.last_used) {
        if ([start laterDate:output.last_used] == output.last_used) {
            start = [output.last_used dateByAddingTimeInterval:tick];
        }
    }
    if ([start laterDate:end] == start) {
        [self.outputLock unlock];
        return;
    }
    
    // PID block
    for (NSDate *slot = start;
         [slot laterDate:end] == end;
         slot = [slot dateByAddingTimeInterval:tick]) {
        NSDate *prev = [slot dateByAddingTimeInterval:(-tick)];
        NSDate *next = [slot dateByAddingTimeInterval:(tick)];

        // Step1: get differential value
        NSUInteger pbits = [dataBase bitsAtDate:prev];
        NSUInteger nbits = [dataBase bitsAtDate:next];
        if (pbits > nbits) {
#ifdef DEBUG
            [dataBase openDebugFile:@"inconsistent_tree.dot"];
            [dataBase dumpTree:TRUE];
#endif
            NSException *ex = [NSException exceptionWithName:@"Inconsistent Data" reason:@"Data is decreadsed." userInfo:NULL];
            [self.outputLock unlock];
            @throw ex;
        }
        NSUInteger bits = nbits - pbits;
        NSUInteger pkts = [dataBase samplesAtDate:slot] - [dataBase samplesAtDate:prev];
        double mbps = (double)bits / (tick * 2.0) * 1.0E-6;
        DerivedData *sample = [DerivedData dataWithDouble:mbps atDate:slot fromSamples:pkts];

        // Step2: FIR
        sample = [filterFIR filter:sample];

        // finalize and output sample
        [output enqueue:sample withTimestamp:slot];
        output.last_used = slot;
    }
    
    // get additional data(noise) generated by filter
    overSample = [output count] - outputSamples;
    [self.outputLock unlock];
}

- (BOOL)FIRenabled
{
    return [filterFIR tap] ? TRUE : FALSE;
}

- (NSDate *)roundDate:(NSDate *)date toTick:(NSTimeInterval)tick
{
    NSTimeInterval unixTime;
    
    unixTime = [date timeIntervalSince1970];
    unixTime = floor(unixTime / tick) * tick;
    return [NSDate dateWithTimeIntervalSince1970:unixTime];
}

- (void)dumpParams
{
    NSLog(@"===== Resampler =====");
    NSLog(@"Duration: %f [sec]", outputTimeLength);
    NSLog(@"Plot: %lu [point]", (unsigned long)outputSamples);
    NSLog(@"Tick: %f [sec/point]", tick);
    NSLog(@"FIR Duration: %f [sec]", FIRTimeLength);
    NSLog(@"FIR Taps: %lu [point]", [filterFIR tap]);
    NSLog(@"Output samples: %lu [point]", outputSamples + [filterFIR tap]);
}

- (void)invalidValueException
{
    NSException *ex;
    
    ex = [NSException exceptionWithName:@"Invalid value"
                                 reason:@"Invalid value in DataResampler"
                               userInfo:nil];
    @throw ex;
}
@end
